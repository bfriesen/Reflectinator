<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".generated.cs" #>
<#@ include file="TemplateFunctions.t4"#>
////////////////////////////////////////////////////////////////////////////////
// This file was generated by a tool. Any manual changes to this file will be //
// lost if/when the file is regenerated. If changes need to be made to this   //
// file, they should be made in Method.tt, which regenerates this file.     //
////////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;

namespace Reflectinator
{
    public abstract class Method : Member, IMethod
    {
        private static readonly ConcurrentDictionary<int, IMethod> _methodsMap = new ConcurrentDictionary<int, IMethod>();

        private readonly MethodInfo _methodInfo;
        private readonly Lazy<Expression<Func<object, object[], object>>> _invokeExpression;
        private readonly Lazy<Func<object, object[], object>> _invoke;

        internal Method(MethodInfo methodInfo)
            : base(methodInfo)
        {
            _methodInfo = methodInfo;
            _invokeExpression = new Lazy<Expression<Func<object, object[], object>>>(() => ExpressionFactory.CreateNonGenericInstanceMethodFuncExpression(methodInfo));
            _invoke = new Lazy<Func<object, object[], object>>(() => _invokeExpression.Value.Compile());
        }

        #region Factory Methods

        public static IMethod Get(MethodInfo methodInfo)
        {
            var parameters = methodInfo.GetParameters().Select(p => p.ParameterType).ToArray();

            return _methodsMap.GetOrAdd(
                methodInfo.GetCacheKey(parameters),
                _ =>
                {
                    var methodType = GetConcreteMethodType(methodInfo, parameters);
                    return (IMethod)Activator.CreateInstance(methodType, BindingFlags.NonPublic | BindingFlags.Instance, null, new object[] { methodInfo }, null);
                });
        }
<#
for (int i = 0; i < MaxNumberOfFuncGenericArguments - 1; i++)
{
#>

        public static FuncMethod<TDeclaringType<# PrintJoinFormat(", ", "TArg{1}", i, true, false); #>, TReturnType> GetFuncMethod<TDeclaringType<# PrintJoinFormat(", ", "TArg{1}", i, true, false); #>, TReturnType>(MethodInfo methodInfo)
        {
            return (FuncMethod<TDeclaringType<# PrintJoinFormat(", ", "TArg{1}", i, true, false); #>, TReturnType>)_methodsMap.GetOrAdd(
                methodInfo.GetCacheKey(<# PrintJoinFormat(", ", "typeof(TArg{1})", i, false, false); #>),
                _ => new FuncMethod<TDeclaringType<# PrintJoinFormat(", ", "TArg{1}", i, true, false); #>, TReturnType>(methodInfo));
        }

        public static ActionMethod<TDeclaringType<# PrintJoinFormat(", ", "TArg{1}", i, true, false); #>> GetActionMethod<TDeclaringType<# PrintJoinFormat(", ", "TArg{1}", i, true, false); #>>(MethodInfo methodInfo)
        {
            return (ActionMethod<TDeclaringType<# PrintJoinFormat(", ", "TArg{1}", i, true, false); #>>)_methodsMap.GetOrAdd(
                methodInfo.GetCacheKey(<# PrintJoinFormat(", ", "typeof(TArg{1})", i, false, false); #>),
                _ => new ActionMethod<TDeclaringType<# PrintJoinFormat(", ", "TArg{1}", i, true, false); #>>(methodInfo));
        }

        public static StaticFuncMethod<TDeclaringType<# PrintJoinFormat(", ", "TArg{1}", i, true, false); #>, TReturnType> GetStaticFuncMethod<TDeclaringType<# PrintJoinFormat(", ", "TArg{1}", i, true, false); #>, TReturnType>(MethodInfo methodInfo)
        {
            return (StaticFuncMethod<TDeclaringType<# PrintJoinFormat(", ", "TArg{1}", i, true, false); #>, TReturnType>)_methodsMap.GetOrAdd(
                methodInfo.GetCacheKey(<# PrintJoinFormat(", ", "typeof(TArg{1})", i, false, false); #>),
                _ => new StaticFuncMethod<TDeclaringType<# PrintJoinFormat(", ", "TArg{1}", i, true, false); #>, TReturnType>(methodInfo));
        }

        public static StaticActionMethod<TDeclaringType<# PrintJoinFormat(", ", "TArg{1}", i, true, false); #>> GetStaticActionMethod<TDeclaringType<# PrintJoinFormat(", ", "TArg{1}", i, true, false); #>>(MethodInfo methodInfo)
        {
            return (StaticActionMethod<TDeclaringType<# PrintJoinFormat(", ", "TArg{1}", i, true, false); #>>)_methodsMap.GetOrAdd(
                methodInfo.GetCacheKey(<# PrintJoinFormat(", ", "typeof(TArg{1})", i, false, false); #>),
                _ => new StaticActionMethod<TDeclaringType<# PrintJoinFormat(", ", "TArg{1}", i, true, false); #>>(methodInfo));
        }
<#
}
#>

        private static Type GetConcreteMethodType(MethodInfo methodInfo, Type [] parameters)
        {
            switch (parameters.Length)
            {
<#
for (int i = 0; i < MaxNumberOfFuncGenericArguments - 1; i++)
{
#>
                case <#= i #>:
                    return GetMethodType(
                            methodInfo,
                            typeof(FuncMethod<<# PrintJoinFormat("", ",", i, false, false); #>,>),
                            typeof(ActionMethod<<# PrintJoinFormat("", ",", i, false, false); #>>),
                            typeof(StaticFuncMethod<<# PrintJoinFormat("", ",", i, false, false); #>,>),
                            typeof(StaticActionMethod<<# PrintJoinFormat("", ",", i, false, false); #>>))
                        .MakeGenericType(GetGenericTypeParameters(methodInfo, parameters));
<#
}
#>
                default:
                    throw new InvalidOperationException();
            }
        }

        private static Type[] GetGenericTypeParameters(MethodInfo methodInfo, Type[] parameters)
        {
            var genericTypeParameters = new List<Type>();

            genericTypeParameters.Add(methodInfo.DeclaringType);
            genericTypeParameters.AddRange(parameters);

            if (methodInfo.ReturnType != typeof(void))
            {
                genericTypeParameters.Add(methodInfo.ReturnType);
            }

            return genericTypeParameters.ToArray();
        }

        private static Type GetMethodType(
            MethodInfo methodInfo,
            Type instanceFuncMethodOpenGenericType,
            Type instanceActionMethodOpenGenericType,
            Type staticFuncMethodOpenGenericType,
            Type staticActionMethodOpenGenericType)
        {
            // On a side note, this I would *really* like to replace this bit of code with proper pattern matching in C#.
            return
                methodInfo.IsStatic
                    ? methodInfo.ReturnType == typeof(void)
                        ? staticActionMethodOpenGenericType
                        : staticFuncMethodOpenGenericType
                    : methodInfo.ReturnType == typeof(void)
                        ? instanceActionMethodOpenGenericType
                        : instanceFuncMethodOpenGenericType;
        }

        #endregion

        public MethodInfo MethodInfo { get { return _methodInfo; } }
        public string Name { get { return _methodInfo.Name; } }

        public override bool IsPublic { get { return _methodInfo.IsPublic; } }
        public override bool IsStatic { get { return false; } }

        object IMethod.Invoke(object instance, params object[] args) { return _invoke.Value(instance, args); }
        Expression<Func<object, object[], object>> IMethod.InvokeExpression { get { return _invokeExpression.Value; } }
        Func<object, object[], object> IMethod.InvokeDelegate { get { return _invoke.Value; } }
    }
}