<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".generated.cs" #>
<#@ include file="TemplateFunctions.t4"#>
////////////////////////////////////////////////////////////////////////////////
// This file was generated by a tool. Any manual changes to this file will be //
// lost if/when the file is regenerated. If changes need to be made to this   //
// file, they should be made in Constructor.tt, which regenerates this file.  //
////////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Concurrent;
using System.Dynamic;
using System.Linq;
using System.Reflection;

namespace Reflectinator
{
    public abstract class Constructor : Member, IConstructor
    {
        private static readonly ConcurrentDictionary<int, IConstructor> _constructorsMap = new ConcurrentDictionary<int, IConstructor>();

        private readonly ConstructorInfo _constructorInfo;
        private readonly Lazy<Func<object[], object>> _invoke;
        private readonly Lazy<ITypeCrawler[]> _parameters;

        internal Constructor(ConstructorInfo constructorInfo)
            : base(constructorInfo)
        {
            if (constructorInfo == null)
            {
                throw new ArgumentNullException("constructorInfo");
            }

            _constructorInfo = constructorInfo;
            _invoke = new Lazy<Func<object[], object>>(() => (Func<object[], object>)ExpressionFactory.CreateConstructorFunc(constructorInfo));
            _parameters = new Lazy<ITypeCrawler[]>(() => constructorInfo.GetParameters().Select(p => TypeCrawler.Get(p.ParameterType)).ToArray());
        }

#region Factory Methods

        public static IConstructor Get(ConstructorInfo constructorInfo)
        {
            var parameters = constructorInfo.GetParameters().Select(p => p.ParameterType).ToArray();

            return _constructorsMap.GetOrAdd(
                constructorInfo.DeclaringType.GetCacheKey(parameters),
                key =>
                {
                    Type constructorType;

                    switch (parameters.Length)
                    {
<#
for (int i = 0; i < MaxNumberOfFuncGenericArguments; i++)
{
#>
                        case <#= i #>:
                            constructorType = typeof(Constructor<<# PrintJoinFormat("", ",", i, false, false); #>>).MakeGenericType(constructorInfo.DeclaringType<# PrintJoinFormat(", ", "parameters[{0}]", i, true, false); #>);
                            break;
<#
}
#>
                        default:
                            throw new InvalidOperationException();
                    }

                    return (IConstructor)Activator.CreateInstance(constructorType, BindingFlags.NonPublic | BindingFlags.Instance, null, new object[] { constructorInfo }, null);
                });
        }
<#
for (int i = 0; i < MaxNumberOfFuncGenericArguments; i++)
{
#>

        public static Constructor<TDeclaringType<# PrintJoinFormat(", ", "TArg{1}", i, true, false); #>> Get<TDeclaringType<# PrintJoinFormat(", ", "TArg{1}", i, true, false); #>>()
        {
            return (Constructor<TDeclaringType<# PrintJoinFormat(", ", "TArg{1}", i, true, false); #>>)_constructorsMap.GetOrAdd(
                typeof(TDeclaringType).GetCacheKey(<# PrintJoinFormat(", ", "typeof(TArg{1})", i, false, false); #>),
                key => new Constructor<TDeclaringType<# PrintJoinFormat(", ", "TArg{1}", i, true, false); #>>());
        }
<#
}
#>

#endregion

        public ConstructorInfo ConstructorInfo { get { return _constructorInfo; } }
        
        public override bool IsPublic { get { return _constructorInfo.IsPublic; } }
        public override bool IsStatic { get { return false; } }

        public ITypeCrawler[] Parameters { get { return _parameters.Value; } }

        object IConstructor.Invoke(params object[] args)
        {
            return _invoke.Value(args);
        }

        Func<object[], object> IConstructor.InvokeFunc { get { return _invoke.Value; } }
    }
}
