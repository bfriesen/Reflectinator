////////////////////////////////////////////////////////////////////////////////
// This file was generated by a tool. Any manual changes to this file will be //
// lost if/when the file is regenerated. Changes should be made in the        //
// Constructor`n.tt file, which regenerates this file.                        //
////////////////////////////////////////////////////////////////////////////////

using System;
using System.Dynamic;
using System.Reflection;

namespace Reflectinator
{
    public sealed class Constructor<TDeclaringType> : Constructor
    {
        private readonly Lazy<Func<TDeclaringType>> _invoke;

        internal Constructor()
            : this(typeof(TDeclaringType).GetConstructorInfo())
        {
        }

        private Constructor(ConstructorInfo constructorInfo)
            : base(constructorInfo)
        {
            _invoke = new Lazy<Func<TDeclaringType>>(() => (Func<TDeclaringType>)FuncFactory.CreateConstructorFunc(ConstructorInfo, true));
        }

        public TDeclaringType Invoke()
        {
            return _invoke.Value();
        }

        public override bool TryInvoke(InvokeBinder binder, object[] args, out object result)
        {
            result = null;

            if (args.Length != 0)
            {
                return false;
            }

            // TODO: verify that all args are able to be assigned to the constructor parameters.

            try
            {
                result = Invoke();
                return true;
            }
            catch
            {
                return false;
            }
        }
    }

    public sealed class Constructor<TDeclaringType, TArg1> : Constructor
    {
        private readonly Lazy<Func<TArg1, TDeclaringType>> _invoke;

        internal Constructor()
            : this(typeof(TDeclaringType).GetConstructorInfo(typeof(TArg1)))
        {
        }

        private Constructor(ConstructorInfo constructorInfo)
            : base(constructorInfo)
        {
            _invoke = new Lazy<Func<TArg1, TDeclaringType>>(() => (Func<TArg1, TDeclaringType>)FuncFactory.CreateConstructorFunc(ConstructorInfo, true));
        }

        public TDeclaringType Invoke(TArg1 arg1)
        {
            return _invoke.Value(arg1);
        }

        public override bool TryInvoke(InvokeBinder binder, object[] args, out object result)
        {
            result = null;

            if (args.Length != 1)
            {
                return false;
            }

            // TODO: verify that all args are able to be assigned to the constructor parameters.

            try
            {
                result = Invoke((TArg1)args[0]);
                return true;
            }
            catch
            {
                return false;
            }
        }
    }

    public sealed class Constructor<TDeclaringType, TArg1, TArg2> : Constructor
    {
        private readonly Lazy<Func<TArg1, TArg2, TDeclaringType>> _invoke;

        internal Constructor()
            : this(typeof(TDeclaringType).GetConstructorInfo(typeof(TArg1), typeof(TArg2)))
        {
        }

        private Constructor(ConstructorInfo constructorInfo)
            : base(constructorInfo)
        {
            _invoke = new Lazy<Func<TArg1, TArg2, TDeclaringType>>(() => (Func<TArg1, TArg2, TDeclaringType>)FuncFactory.CreateConstructorFunc(ConstructorInfo, true));
        }

        public TDeclaringType Invoke(TArg1 arg1, TArg2 arg2)
        {
            return _invoke.Value(arg1, arg2);
        }

        public override bool TryInvoke(InvokeBinder binder, object[] args, out object result)
        {
            result = null;

            if (args.Length != 2)
            {
                return false;
            }

            // TODO: verify that all args are able to be assigned to the constructor parameters.

            try
            {
                result = Invoke((TArg1)args[0], (TArg2)args[1]);
                return true;
            }
            catch
            {
                return false;
            }
        }
    }

    public sealed class Constructor<TDeclaringType, TArg1, TArg2, TArg3> : Constructor
    {
        private readonly Lazy<Func<TArg1, TArg2, TArg3, TDeclaringType>> _invoke;

        internal Constructor()
            : this(typeof(TDeclaringType).GetConstructorInfo(typeof(TArg1), typeof(TArg2), typeof(TArg3)))
        {
        }

        private Constructor(ConstructorInfo constructorInfo)
            : base(constructorInfo)
        {
            _invoke = new Lazy<Func<TArg1, TArg2, TArg3, TDeclaringType>>(() => (Func<TArg1, TArg2, TArg3, TDeclaringType>)FuncFactory.CreateConstructorFunc(ConstructorInfo, true));
        }

        public TDeclaringType Invoke(TArg1 arg1, TArg2 arg2, TArg3 arg3)
        {
            return _invoke.Value(arg1, arg2, arg3);
        }

        public override bool TryInvoke(InvokeBinder binder, object[] args, out object result)
        {
            result = null;

            if (args.Length != 3)
            {
                return false;
            }

            // TODO: verify that all args are able to be assigned to the constructor parameters.

            try
            {
                result = Invoke((TArg1)args[0], (TArg2)args[1], (TArg3)args[2]);
                return true;
            }
            catch
            {
                return false;
            }
        }
    }

    public sealed class Constructor<TDeclaringType, TArg1, TArg2, TArg3, TArg4> : Constructor
    {
        private readonly Lazy<Func<TArg1, TArg2, TArg3, TArg4, TDeclaringType>> _invoke;

        internal Constructor()
            : this(typeof(TDeclaringType).GetConstructorInfo(typeof(TArg1), typeof(TArg2), typeof(TArg3), typeof(TArg4)))
        {
        }

        private Constructor(ConstructorInfo constructorInfo)
            : base(constructorInfo)
        {
            _invoke = new Lazy<Func<TArg1, TArg2, TArg3, TArg4, TDeclaringType>>(() => (Func<TArg1, TArg2, TArg3, TArg4, TDeclaringType>)FuncFactory.CreateConstructorFunc(ConstructorInfo, true));
        }

        public TDeclaringType Invoke(TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4)
        {
            return _invoke.Value(arg1, arg2, arg3, arg4);
        }

        public override bool TryInvoke(InvokeBinder binder, object[] args, out object result)
        {
            result = null;

            if (args.Length != 4)
            {
                return false;
            }

            // TODO: verify that all args are able to be assigned to the constructor parameters.

            try
            {
                result = Invoke((TArg1)args[0], (TArg2)args[1], (TArg3)args[2], (TArg4)args[3]);
                return true;
            }
            catch
            {
                return false;
            }
        }
    }

    public sealed class Constructor<TDeclaringType, TArg1, TArg2, TArg3, TArg4, TArg5> : Constructor
    {
        private readonly Lazy<Func<TArg1, TArg2, TArg3, TArg4, TArg5, TDeclaringType>> _invoke;

        internal Constructor()
            : this(typeof(TDeclaringType).GetConstructorInfo(typeof(TArg1), typeof(TArg2), typeof(TArg3), typeof(TArg4), typeof(TArg5)))
        {
        }

        private Constructor(ConstructorInfo constructorInfo)
            : base(constructorInfo)
        {
            _invoke = new Lazy<Func<TArg1, TArg2, TArg3, TArg4, TArg5, TDeclaringType>>(() => (Func<TArg1, TArg2, TArg3, TArg4, TArg5, TDeclaringType>)FuncFactory.CreateConstructorFunc(ConstructorInfo, true));
        }

        public TDeclaringType Invoke(TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4, TArg5 arg5)
        {
            return _invoke.Value(arg1, arg2, arg3, arg4, arg5);
        }

        public override bool TryInvoke(InvokeBinder binder, object[] args, out object result)
        {
            result = null;

            if (args.Length != 5)
            {
                return false;
            }

            // TODO: verify that all args are able to be assigned to the constructor parameters.

            try
            {
                result = Invoke((TArg1)args[0], (TArg2)args[1], (TArg3)args[2], (TArg4)args[3], (TArg5)args[4]);
                return true;
            }
            catch
            {
                return false;
            }
        }
    }

    public sealed class Constructor<TDeclaringType, TArg1, TArg2, TArg3, TArg4, TArg5, TArg6> : Constructor
    {
        private readonly Lazy<Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TDeclaringType>> _invoke;

        internal Constructor()
            : this(typeof(TDeclaringType).GetConstructorInfo(typeof(TArg1), typeof(TArg2), typeof(TArg3), typeof(TArg4), typeof(TArg5), typeof(TArg6)))
        {
        }

        private Constructor(ConstructorInfo constructorInfo)
            : base(constructorInfo)
        {
            _invoke = new Lazy<Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TDeclaringType>>(() => (Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TDeclaringType>)FuncFactory.CreateConstructorFunc(ConstructorInfo, true));
        }

        public TDeclaringType Invoke(TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4, TArg5 arg5, TArg6 arg6)
        {
            return _invoke.Value(arg1, arg2, arg3, arg4, arg5, arg6);
        }

        public override bool TryInvoke(InvokeBinder binder, object[] args, out object result)
        {
            result = null;

            if (args.Length != 6)
            {
                return false;
            }

            // TODO: verify that all args are able to be assigned to the constructor parameters.

            try
            {
                result = Invoke((TArg1)args[0], (TArg2)args[1], (TArg3)args[2], (TArg4)args[3], (TArg5)args[4], (TArg6)args[5]);
                return true;
            }
            catch
            {
                return false;
            }
        }
    }

    public sealed class Constructor<TDeclaringType, TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7> : Constructor
    {
        private readonly Lazy<Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TDeclaringType>> _invoke;

        internal Constructor()
            : this(typeof(TDeclaringType).GetConstructorInfo(typeof(TArg1), typeof(TArg2), typeof(TArg3), typeof(TArg4), typeof(TArg5), typeof(TArg6), typeof(TArg7)))
        {
        }

        private Constructor(ConstructorInfo constructorInfo)
            : base(constructorInfo)
        {
            _invoke = new Lazy<Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TDeclaringType>>(() => (Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TDeclaringType>)FuncFactory.CreateConstructorFunc(ConstructorInfo, true));
        }

        public TDeclaringType Invoke(TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4, TArg5 arg5, TArg6 arg6, TArg7 arg7)
        {
            return _invoke.Value(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
        }

        public override bool TryInvoke(InvokeBinder binder, object[] args, out object result)
        {
            result = null;

            if (args.Length != 7)
            {
                return false;
            }

            // TODO: verify that all args are able to be assigned to the constructor parameters.

            try
            {
                result = Invoke((TArg1)args[0], (TArg2)args[1], (TArg3)args[2], (TArg4)args[3], (TArg5)args[4], (TArg6)args[5], (TArg7)args[6]);
                return true;
            }
            catch
            {
                return false;
            }
        }
    }

    public sealed class Constructor<TDeclaringType, TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8> : Constructor
    {
        private readonly Lazy<Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TDeclaringType>> _invoke;

        internal Constructor()
            : this(typeof(TDeclaringType).GetConstructorInfo(typeof(TArg1), typeof(TArg2), typeof(TArg3), typeof(TArg4), typeof(TArg5), typeof(TArg6), typeof(TArg7), typeof(TArg8)))
        {
        }

        private Constructor(ConstructorInfo constructorInfo)
            : base(constructorInfo)
        {
            _invoke = new Lazy<Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TDeclaringType>>(() => (Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TDeclaringType>)FuncFactory.CreateConstructorFunc(ConstructorInfo, true));
        }

        public TDeclaringType Invoke(TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4, TArg5 arg5, TArg6 arg6, TArg7 arg7, TArg8 arg8)
        {
            return _invoke.Value(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
        }

        public override bool TryInvoke(InvokeBinder binder, object[] args, out object result)
        {
            result = null;

            if (args.Length != 8)
            {
                return false;
            }

            // TODO: verify that all args are able to be assigned to the constructor parameters.

            try
            {
                result = Invoke((TArg1)args[0], (TArg2)args[1], (TArg3)args[2], (TArg4)args[3], (TArg5)args[4], (TArg6)args[5], (TArg7)args[6], (TArg8)args[7]);
                return true;
            }
            catch
            {
                return false;
            }
        }
    }

    public sealed class Constructor<TDeclaringType, TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9> : Constructor
    {
        private readonly Lazy<Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TDeclaringType>> _invoke;

        internal Constructor()
            : this(typeof(TDeclaringType).GetConstructorInfo(typeof(TArg1), typeof(TArg2), typeof(TArg3), typeof(TArg4), typeof(TArg5), typeof(TArg6), typeof(TArg7), typeof(TArg8), typeof(TArg9)))
        {
        }

        private Constructor(ConstructorInfo constructorInfo)
            : base(constructorInfo)
        {
            _invoke = new Lazy<Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TDeclaringType>>(() => (Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TDeclaringType>)FuncFactory.CreateConstructorFunc(ConstructorInfo, true));
        }

        public TDeclaringType Invoke(TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4, TArg5 arg5, TArg6 arg6, TArg7 arg7, TArg8 arg8, TArg9 arg9)
        {
            return _invoke.Value(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
        }

        public override bool TryInvoke(InvokeBinder binder, object[] args, out object result)
        {
            result = null;

            if (args.Length != 9)
            {
                return false;
            }

            // TODO: verify that all args are able to be assigned to the constructor parameters.

            try
            {
                result = Invoke((TArg1)args[0], (TArg2)args[1], (TArg3)args[2], (TArg4)args[3], (TArg5)args[4], (TArg6)args[5], (TArg7)args[6], (TArg8)args[7], (TArg9)args[8]);
                return true;
            }
            catch
            {
                return false;
            }
        }
    }

    public sealed class Constructor<TDeclaringType, TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10> : Constructor
    {
        private readonly Lazy<Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10, TDeclaringType>> _invoke;

        internal Constructor()
            : this(typeof(TDeclaringType).GetConstructorInfo(typeof(TArg1), typeof(TArg2), typeof(TArg3), typeof(TArg4), typeof(TArg5), typeof(TArg6), typeof(TArg7), typeof(TArg8), typeof(TArg9), typeof(TArg10)))
        {
        }

        private Constructor(ConstructorInfo constructorInfo)
            : base(constructorInfo)
        {
            _invoke = new Lazy<Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10, TDeclaringType>>(() => (Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10, TDeclaringType>)FuncFactory.CreateConstructorFunc(ConstructorInfo, true));
        }

        public TDeclaringType Invoke(TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4, TArg5 arg5, TArg6 arg6, TArg7 arg7, TArg8 arg8, TArg9 arg9, TArg10 arg10)
        {
            return _invoke.Value(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
        }

        public override bool TryInvoke(InvokeBinder binder, object[] args, out object result)
        {
            result = null;

            if (args.Length != 10)
            {
                return false;
            }

            // TODO: verify that all args are able to be assigned to the constructor parameters.

            try
            {
                result = Invoke((TArg1)args[0], (TArg2)args[1], (TArg3)args[2], (TArg4)args[3], (TArg5)args[4], (TArg6)args[5], (TArg7)args[6], (TArg8)args[7], (TArg9)args[8], (TArg10)args[9]);
                return true;
            }
            catch
            {
                return false;
            }
        }
    }

    public sealed class Constructor<TDeclaringType, TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10, TArg11> : Constructor
    {
        private readonly Lazy<Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10, TArg11, TDeclaringType>> _invoke;

        internal Constructor()
            : this(typeof(TDeclaringType).GetConstructorInfo(typeof(TArg1), typeof(TArg2), typeof(TArg3), typeof(TArg4), typeof(TArg5), typeof(TArg6), typeof(TArg7), typeof(TArg8), typeof(TArg9), typeof(TArg10), typeof(TArg11)))
        {
        }

        private Constructor(ConstructorInfo constructorInfo)
            : base(constructorInfo)
        {
            _invoke = new Lazy<Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10, TArg11, TDeclaringType>>(() => (Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10, TArg11, TDeclaringType>)FuncFactory.CreateConstructorFunc(ConstructorInfo, true));
        }

        public TDeclaringType Invoke(TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4, TArg5 arg5, TArg6 arg6, TArg7 arg7, TArg8 arg8, TArg9 arg9, TArg10 arg10, TArg11 arg11)
        {
            return _invoke.Value(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
        }

        public override bool TryInvoke(InvokeBinder binder, object[] args, out object result)
        {
            result = null;

            if (args.Length != 11)
            {
                return false;
            }

            // TODO: verify that all args are able to be assigned to the constructor parameters.

            try
            {
                result = Invoke((TArg1)args[0], (TArg2)args[1], (TArg3)args[2], (TArg4)args[3], (TArg5)args[4], (TArg6)args[5], (TArg7)args[6], (TArg8)args[7], (TArg9)args[8], (TArg10)args[9], (TArg11)args[10]);
                return true;
            }
            catch
            {
                return false;
            }
        }
    }

    public sealed class Constructor<TDeclaringType, TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10, TArg11, TArg12> : Constructor
    {
        private readonly Lazy<Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10, TArg11, TArg12, TDeclaringType>> _invoke;

        internal Constructor()
            : this(typeof(TDeclaringType).GetConstructorInfo(typeof(TArg1), typeof(TArg2), typeof(TArg3), typeof(TArg4), typeof(TArg5), typeof(TArg6), typeof(TArg7), typeof(TArg8), typeof(TArg9), typeof(TArg10), typeof(TArg11), typeof(TArg12)))
        {
        }

        private Constructor(ConstructorInfo constructorInfo)
            : base(constructorInfo)
        {
            _invoke = new Lazy<Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10, TArg11, TArg12, TDeclaringType>>(() => (Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10, TArg11, TArg12, TDeclaringType>)FuncFactory.CreateConstructorFunc(ConstructorInfo, true));
        }

        public TDeclaringType Invoke(TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4, TArg5 arg5, TArg6 arg6, TArg7 arg7, TArg8 arg8, TArg9 arg9, TArg10 arg10, TArg11 arg11, TArg12 arg12)
        {
            return _invoke.Value(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
        }

        public override bool TryInvoke(InvokeBinder binder, object[] args, out object result)
        {
            result = null;

            if (args.Length != 12)
            {
                return false;
            }

            // TODO: verify that all args are able to be assigned to the constructor parameters.

            try
            {
                result = Invoke((TArg1)args[0], (TArg2)args[1], (TArg3)args[2], (TArg4)args[3], (TArg5)args[4], (TArg6)args[5], (TArg7)args[6], (TArg8)args[7], (TArg9)args[8], (TArg10)args[9], (TArg11)args[10], (TArg12)args[11]);
                return true;
            }
            catch
            {
                return false;
            }
        }
    }

    public sealed class Constructor<TDeclaringType, TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10, TArg11, TArg12, TArg13> : Constructor
    {
        private readonly Lazy<Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10, TArg11, TArg12, TArg13, TDeclaringType>> _invoke;

        internal Constructor()
            : this(typeof(TDeclaringType).GetConstructorInfo(typeof(TArg1), typeof(TArg2), typeof(TArg3), typeof(TArg4), typeof(TArg5), typeof(TArg6), typeof(TArg7), typeof(TArg8), typeof(TArg9), typeof(TArg10), typeof(TArg11), typeof(TArg12), typeof(TArg13)))
        {
        }

        private Constructor(ConstructorInfo constructorInfo)
            : base(constructorInfo)
        {
            _invoke = new Lazy<Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10, TArg11, TArg12, TArg13, TDeclaringType>>(() => (Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10, TArg11, TArg12, TArg13, TDeclaringType>)FuncFactory.CreateConstructorFunc(ConstructorInfo, true));
        }

        public TDeclaringType Invoke(TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4, TArg5 arg5, TArg6 arg6, TArg7 arg7, TArg8 arg8, TArg9 arg9, TArg10 arg10, TArg11 arg11, TArg12 arg12, TArg13 arg13)
        {
            return _invoke.Value(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
        }

        public override bool TryInvoke(InvokeBinder binder, object[] args, out object result)
        {
            result = null;

            if (args.Length != 13)
            {
                return false;
            }

            // TODO: verify that all args are able to be assigned to the constructor parameters.

            try
            {
                result = Invoke((TArg1)args[0], (TArg2)args[1], (TArg3)args[2], (TArg4)args[3], (TArg5)args[4], (TArg6)args[5], (TArg7)args[6], (TArg8)args[7], (TArg9)args[8], (TArg10)args[9], (TArg11)args[10], (TArg12)args[11], (TArg13)args[12]);
                return true;
            }
            catch
            {
                return false;
            }
        }
    }

    public sealed class Constructor<TDeclaringType, TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10, TArg11, TArg12, TArg13, TArg14> : Constructor
    {
        private readonly Lazy<Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10, TArg11, TArg12, TArg13, TArg14, TDeclaringType>> _invoke;

        internal Constructor()
            : this(typeof(TDeclaringType).GetConstructorInfo(typeof(TArg1), typeof(TArg2), typeof(TArg3), typeof(TArg4), typeof(TArg5), typeof(TArg6), typeof(TArg7), typeof(TArg8), typeof(TArg9), typeof(TArg10), typeof(TArg11), typeof(TArg12), typeof(TArg13), typeof(TArg14)))
        {
        }

        private Constructor(ConstructorInfo constructorInfo)
            : base(constructorInfo)
        {
            _invoke = new Lazy<Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10, TArg11, TArg12, TArg13, TArg14, TDeclaringType>>(() => (Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10, TArg11, TArg12, TArg13, TArg14, TDeclaringType>)FuncFactory.CreateConstructorFunc(ConstructorInfo, true));
        }

        public TDeclaringType Invoke(TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4, TArg5 arg5, TArg6 arg6, TArg7 arg7, TArg8 arg8, TArg9 arg9, TArg10 arg10, TArg11 arg11, TArg12 arg12, TArg13 arg13, TArg14 arg14)
        {
            return _invoke.Value(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
        }

        public override bool TryInvoke(InvokeBinder binder, object[] args, out object result)
        {
            result = null;

            if (args.Length != 14)
            {
                return false;
            }

            // TODO: verify that all args are able to be assigned to the constructor parameters.

            try
            {
                result = Invoke((TArg1)args[0], (TArg2)args[1], (TArg3)args[2], (TArg4)args[3], (TArg5)args[4], (TArg6)args[5], (TArg7)args[6], (TArg8)args[7], (TArg9)args[8], (TArg10)args[9], (TArg11)args[10], (TArg12)args[11], (TArg13)args[12], (TArg14)args[13]);
                return true;
            }
            catch
            {
                return false;
            }
        }
    }

    public sealed class Constructor<TDeclaringType, TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10, TArg11, TArg12, TArg13, TArg14, TArg15> : Constructor
    {
        private readonly Lazy<Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10, TArg11, TArg12, TArg13, TArg14, TArg15, TDeclaringType>> _invoke;

        internal Constructor()
            : this(typeof(TDeclaringType).GetConstructorInfo(typeof(TArg1), typeof(TArg2), typeof(TArg3), typeof(TArg4), typeof(TArg5), typeof(TArg6), typeof(TArg7), typeof(TArg8), typeof(TArg9), typeof(TArg10), typeof(TArg11), typeof(TArg12), typeof(TArg13), typeof(TArg14), typeof(TArg15)))
        {
        }

        private Constructor(ConstructorInfo constructorInfo)
            : base(constructorInfo)
        {
            _invoke = new Lazy<Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10, TArg11, TArg12, TArg13, TArg14, TArg15, TDeclaringType>>(() => (Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10, TArg11, TArg12, TArg13, TArg14, TArg15, TDeclaringType>)FuncFactory.CreateConstructorFunc(ConstructorInfo, true));
        }

        public TDeclaringType Invoke(TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4, TArg5 arg5, TArg6 arg6, TArg7 arg7, TArg8 arg8, TArg9 arg9, TArg10 arg10, TArg11 arg11, TArg12 arg12, TArg13 arg13, TArg14 arg14, TArg15 arg15)
        {
            return _invoke.Value(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
        }

        public override bool TryInvoke(InvokeBinder binder, object[] args, out object result)
        {
            result = null;

            if (args.Length != 15)
            {
                return false;
            }

            // TODO: verify that all args are able to be assigned to the constructor parameters.

            try
            {
                result = Invoke((TArg1)args[0], (TArg2)args[1], (TArg3)args[2], (TArg4)args[3], (TArg5)args[4], (TArg6)args[5], (TArg7)args[6], (TArg8)args[7], (TArg9)args[8], (TArg10)args[9], (TArg11)args[10], (TArg12)args[11], (TArg13)args[12], (TArg14)args[13], (TArg15)args[14]);
                return true;
            }
            catch
            {
                return false;
            }
        }
    }

    public sealed class Constructor<TDeclaringType, TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10, TArg11, TArg12, TArg13, TArg14, TArg15, TArg16> : Constructor
    {
        private readonly Lazy<Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10, TArg11, TArg12, TArg13, TArg14, TArg15, TArg16, TDeclaringType>> _invoke;

        internal Constructor()
            : this(typeof(TDeclaringType).GetConstructorInfo(typeof(TArg1), typeof(TArg2), typeof(TArg3), typeof(TArg4), typeof(TArg5), typeof(TArg6), typeof(TArg7), typeof(TArg8), typeof(TArg9), typeof(TArg10), typeof(TArg11), typeof(TArg12), typeof(TArg13), typeof(TArg14), typeof(TArg15), typeof(TArg16)))
        {
        }

        private Constructor(ConstructorInfo constructorInfo)
            : base(constructorInfo)
        {
            _invoke = new Lazy<Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10, TArg11, TArg12, TArg13, TArg14, TArg15, TArg16, TDeclaringType>>(() => (Func<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10, TArg11, TArg12, TArg13, TArg14, TArg15, TArg16, TDeclaringType>)FuncFactory.CreateConstructorFunc(ConstructorInfo, true));
        }

        public TDeclaringType Invoke(TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4, TArg5 arg5, TArg6 arg6, TArg7 arg7, TArg8 arg8, TArg9 arg9, TArg10 arg10, TArg11 arg11, TArg12 arg12, TArg13 arg13, TArg14 arg14, TArg15 arg15, TArg16 arg16)
        {
            return _invoke.Value(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
        }

        public override bool TryInvoke(InvokeBinder binder, object[] args, out object result)
        {
            result = null;

            if (args.Length != 16)
            {
                return false;
            }

            // TODO: verify that all args are able to be assigned to the constructor parameters.

            try
            {
                result = Invoke((TArg1)args[0], (TArg2)args[1], (TArg3)args[2], (TArg4)args[3], (TArg5)args[4], (TArg6)args[5], (TArg7)args[6], (TArg8)args[7], (TArg9)args[8], (TArg10)args[9], (TArg11)args[10], (TArg12)args[11], (TArg13)args[12], (TArg14)args[13], (TArg15)args[14], (TArg16)args[15]);
                return true;
            }
            catch
            {
                return false;
            }
        }
    }
}
