<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".generated.cs" #>
<#@ include file="TemplateFunctions.t4"#>
////////////////////////////////////////////////////////////////////////////////
// This file was generated by a tool. Any manual changes to this file will be //
// lost if/when the file is regenerated. If changes need to be made to this   //
// file, they should be made in Constructor.tt, which regenerates this file.  //
////////////////////////////////////////////////////////////////////////////////

using System;
using System.Dynamic;
using System.Linq.Expressions;
using System.Reflection;

namespace Reflectinator
{
<#
for (int i = 0; i < MaxNumberOfFuncGenericArguments; i++)
{
#>
    public sealed class Constructor<TDeclaringType<# PrintJoinFormat(", ", "TArg{1}", i, true, false); #>> : Constructor
    {
        private static readonly Type[] _argTypes = new Type[] {<# PrintJoinFormat(", ", "typeof(TArg{1})", i, false, false, 1); #>};

        private readonly Lazy<Expression<Func<<# PrintJoinFormat(", ", "TArg{1}", i, false, true); #>TDeclaringType>>> _invokeExpression;
        private readonly Lazy<Func<<# PrintJoinFormat(", ", "TArg{1}", i, false, true); #>TDeclaringType>> _invoke;

        internal Constructor()
            : this(typeof(TDeclaringType).GetConstructorInfo(_argTypes))
        {
        }

        internal Constructor(ConstructorInfo constructorInfo)
            : base(constructorInfo)
        {
            _invokeExpression = new Lazy<Expression<Func<<# PrintJoinFormat(", ", "TArg{1}", i, false, true); #>TDeclaringType>>>(() => ExpressionFactory.CreateConstructorFuncExpression<TDeclaringType<# PrintJoinFormat(", ", "TArg{1}", i, true, false); #>>(constructorInfo));
            _invoke = new Lazy<Func<<# PrintJoinFormat(", ", "TArg{1}", i, false, true); #>TDeclaringType>>(() => _invokeExpression.Value.Compile());
        }

        public TDeclaringType Invoke(<# PrintJoinFormat(", ", "TArg{1} arg{1}", i, false, false); #>) { return _invoke.Value(<# PrintJoinFormat(", ", "arg{1}", i, false, false); #>); }
        public Expression<Func<<# PrintJoinFormat(", ", "TArg{1}", i, false, true); #>TDeclaringType>> InvokeExpression { get { return _invokeExpression.Value; } }
        public Func<<# PrintJoinFormat(", ", "TArg{1}", i, false, true); #>TDeclaringType> InvokeFunc { get { return _invoke.Value; } }
    }

<#
}
#>
}
