<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".generated.cs" #>
<#@ include file="TemplateFunctions.t4"#>
using System;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;

namespace Reflectinator
{
    public static partial class FuncFactory
    {
<#
for (int i = 0; i < 17; i++)
{
#>
        public static Func<<# PrintJoinFormat(", ", "TArg{1}", i, false, true); #>TReturnType> CreateConstructorFunc<TReturnType<# PrintJoinFormat(", ", "TArg{1}", i, true, false); #>>(ConstructorInfo ctor = null)
        {
            if (ctor == null)
            {
                ctor = typeof(TReturnType).GetConstructor(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance, null, new Type[] { <# PrintJoinFormat(", ", "typeof(TArg{1})", i, false, false); #> }, null);

                if (ctor == null)
                {
                    throw new MissingMemberException(string.Format("Unable to find a constructor with the following types: (<# PrintJoinFormat(", ", "{{{0}}}", i, false, false); #>)"<# PrintJoinFormat(", ", "typeof(TArg{1}).Name", i, true, false); #>));
                }
            }

            var ctorParameters = ctor.GetParameters();

            if (ctorParameters.Length != <#= i #>)
            {
                throw new ArgumentException(string.Format("ConstructorInfo has wrong number of parameters. Should be <#= i #>, but was {0}.", ctorParameters.Length), "ctor");
            }

            var parameters = new ParameterExpression[] { <# PrintJoinFormat(", ", "Expression.Parameter(typeof(TArg{1}), \"arg{1}\")", i, false, false); #> };
            var coercedParameters = parameters.Zip(
                ctorParameters,
                (parameterExpression, parameterInfo) =>
                    parameterExpression.Coerce(parameterExpression.Type, parameterInfo.ParameterType));

            var newExpression = Expression.New(ctor, coercedParameters);
            var newCast = newExpression.Coerce(ctor.DeclaringType, typeof(TReturnType));

            var expression = Expression.Lambda<Func<<# PrintJoinFormat(", ", "TArg{1}", i, false, true); #>TReturnType>>(newCast, parameters);
            return expression.Compile();
        }

<#
}
#>
    }
}